https://leetcode.com/problems/combination-sum-ii/

Given a collection of candidate numbers (candidates) and a target number (target), 
find all unique combinations in candidates where the candidate numbers sum to target. 
Each number in candidates may only be used once in the combination.
Note: The solution set must not contain duplicate combinations.

Example:
Input: candidates = [10,1,2,7,6,1,5], target = 8
Output: 
[[1,1,6],
[1,2,5],
[1,7],
[2,6]]

# Java soln 1- (gives TLE coz of high TC: (2^n)*k*logn)
# similar to com sum 1, just used HashSet to handle duplicate and made ind +1 in pick condition

class Solution {
    public void cs(int[] cand, int tar, int ind, int n, List<Integer> temp, HashSet<List<Integer>> set){
        if(ind == n || tar<= 0){
            if(tar == 0) set.add(new ArrayList<>(temp));
            return;
        }
        cs(cand, tar, ind+1, n, temp, set);
        
        temp.add(cand[ind]);
        cs(cand, tar-cand[ind], ind+1, n, temp, set); // ind + 1-> each number be used once in the combination
        temp.remove(temp.size()-1);
    }
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        int n= candidates.length;
        Arrays.sort(candidates);
        HashSet<List<Integer>> set = new HashSet<>(); //to handle duplicate

        cs(candidates, target, 0, n, new ArrayList<>(), set);

        List<List<Integer>> ans = new ArrayList<>();
        for(List<Integer> i : set) ans.add(i); / convertion Set to list
        return ans;
    }
}

# Soln 2-

class Solution {
    public void cs(int[] cand, int tar, int ind, int n, List<Integer> temp, List<List<Integer>> ans){
        if(tar== 0){
             ans.add(new ArrayList<>(temp));
            return;
        }
        for(int i = ind; i<n;i++){
            if(i>ind && cand[i]==cand[i-1]) continue;
            else if(cand[i]>tar) break;

            temp.add(cand[i]);
            cs(cand, tar-cand[i], i+1, n, temp, ans);
            temp.remove(temp.size()-1);
        }
    }
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        int n= candidates.length;
        Arrays.sort(candidates);
        List<List<Integer>> ans = new ArrayList<>();

        cs(candidates, target, 0, n, new ArrayList<>(), ans);
        return ans;
    }
}
