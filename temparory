1.

DP I

public class Solution {

    public int fib(int n) {
        int[] dp = new int[n + 1]; // Initialize dp array
        for (int i = 0; i <= n; i++) {
            dp[i] = -1; // Set initial values to -1
        }
        return f(n, dp); // Call the recursive function
    }

    private int f(int n, int[] dp) {
        // Base cases
        if (n == 0 || n == 1) {
            dp[n] = n;
            return dp[n];
        }
        // If the value is already computed, return it
        if (dp[n] != -1) {
            return dp[n];
        }
        // Recursively calculate the Fibonacci numbers
        int l = f(n - 1, dp);
        int r = f(n - 2, dp);
        dp[n] = l + r; // Store the result in dp[n]
        return dp[n];  // Return the result
    }

    public static void main(String[] args) {
        Solution sol = new Solution();
        System.out.println(sol.fib(10)); // Example usage: print the 10th Fibonacci number
    }
}

DP II

public class Solution {
    
    public int fib(int n) {
        if (n <= 1) {
            return n;
        }
        
        int[] dp = new int[n + 1];
        
        dp[0] = 0; // Base case: Fib(0) = 0
        dp[1] = 1; // Base case: Fib(1) = 1
        
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2]; // Fib(i) = Fib(i - 1) + Fib(i - 2)
        }
        
        return dp[n]; // Return the n-th Fibonacci number
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        System.out.println(solution.fib(10)); // Example usage
    }
}

DP III

public class Solution {
    
    public int fib(int n) {
        if (n <= 1) {
            return n; // If n is 0 or 1, return n (base cases)
        }

        int prev1 = 0; // Base case: Fib(0)
        int prev2 = 1; // Base case: Fib(1)
        int finalFib = 0; // To store the final Fibonacci value

        for (int i = 2; i <= n; i++) {
            finalFib = prev1 + prev2; // Current Fibonacci number
            prev1 = prev2; // Update prev1 to the previous value of prev2
            prev2 = finalFib; // Update prev2 to the current Fibonacci number
        }

        return finalFib; // Return the nth Fibonacci number
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        System.out.println(solution.fib(10)); // Example usage: should print the 10th Fibonacci number
    }
}

2.

DP I

public class Solution {

    public int climbStairs(int n) {
        int[] dp = new int[n + 1]; // Create a dp array of size n+1
        for (int i = 0; i <= n; i++) {
            dp[i] = -1; // Initialize dp array with -1
        }
        return f(n, dp); // Call the helper function
    }

    private int f(int n, int[] dp) {
        if (n == 0) {
            dp[0] = 1; // Base case: 1 way to stay at the ground (0th step)
            return dp[0];
        }
        if (n == 1) {
            dp[1] = 1; // Base case: 1 way to reach the 1st step
            return dp[1];
        }

        if (dp[n] != -1) {
            return dp[n]; // Return already computed result
        }

        dp[n] = f(n - 2, dp) + f(n - 1, dp); // Compute the number of ways for the nth step
        return dp[n];
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        System.out.println(solution.climbStairs(5)); // Example usage: should print the number of ways to climb 5 stairs
    }
}

DP II
